const wigleData = new Map(); // Store as { "MAC": {lat, lon, ssid} }

function parseWigleCSV(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const lines = e.target.result.split('\n');
        // WiGle CSVs usually start with headers on line 2
        for (let i = 2; i < lines.length; i++) {
            const cols = lines[i].split(',');
            if (cols.length < 10) continue;

            const mac = cols[0].trim(); // BSSID
            const ssid = cols[1].trim();
            const lat = parseFloat(cols[3]);
            const lon = parseFloat(cols[4]);

            wigleData.set(mac, { lat, lon, ssid });
        }
        console.log(`Loaded ${wigleData.size} networks from WiGle.`);
    };
    reader.readAsText(file);
}


function calculateBearing(lat1, lon1, lat2, lon2) {
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
    const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
              Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
    let brng = Math.atan2(y, x) * 180 / Math.PI;
    return (brng + 360) % 360; // Normalize to 0-360
}

// Rotate the UI arrow based on Phone Orientation
window.addEventListener("deviceorientationabsolute", (event) => {
    const heading = event.alpha; // Magnetic North
    const arrow = document.getElementById("compass-arrow");
    // targetBearing comes from the WiGle correlation
    arrow.style.transform = `rotate(${targetBearing - heading}deg)`;
});


let port;
let reader;
const networkMap = new Map(); // Stores { BSSID: { ssid, rssiHistory, baseline } }
const DROP_THRESHOLD = 8;     // Sensitivity: dBm drop to trigger alert

async function connectSerial() {
    try {
        // Request a port and open it
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        
        const textDecoder = new TextDecoderStream();
        const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();

        readLoop();
    } catch (e) {
        console.error("Serial Connection Failed:", e);
    }
}

async function readLoop() {
    let buffer = "";
    while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += value;
        
        if (buffer.includes("\n")) {
            let lines = buffer.split("\n");
            buffer = lines.pop(); // Keep partial line for next loop
            lines.forEach(parseLine);
        }
    }
}

function parseLine(line) {
    // Expected format from ESP8266: "XX:XX:XX:XX:XX:XX,SSID,-65"
    const data = line.split(",");
    if (data.length < 3) return;

    const bssid = data[0].trim();
    const ssid = data[1].trim();
    const rssi = parseInt(data[2]);

    if (!networkMap.has(bssid)) {
        networkMap.set(bssid, { ssid, baseline: rssi, current: rssi });
    } else {
        let net = networkMap.get(bssid);
        // Simple smoothing: 80% old, 20% new
        net.baseline = (net.baseline * 0.8) + (rssi * 0.2);
        
        // Detect "Shadowing" (The Person)
        const drop = net.baseline - rssi;
        if (drop > DROP_THRESHOLD) {
            triggerAlert(bssid, ssid, drop);
        }
        net.current = rssi;
    }
}
